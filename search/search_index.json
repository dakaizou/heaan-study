{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"Environment%20Setup/","text":"HEAAN Compile from source Platform: Ubuntu 20.04 Steps: Install GMP sudo apt install libgmp3-dev Compile and install NTL curl -LO https://libntl.org/ntl-11.5.1.tar.gz gunzip ntl-11.5.1.tar.gz tar xvf ntl-11.5.1.tar cd ntl-11.5.1/src ./configure make sudo make install Compile HEAAN git clone git@github.com:snucrypto/HEAAN.git cd HEAAN/HEAAN/lib make Run some tests cd ../run ( HEAAN/HEAAN/run ) make ./TestHEAAN Encrypt","title":"Environment Setup"},{"location":"References/","text":"Original paper for HEAAN Talk about HEAAN ( slide ) TFHE: Fast Fully Homomorphic Encryption over the Torus (Used by Zama.ai's concrete ) Logistic regression model training based on the approximate homomorphic encryption (iDASH) Secure logistic regression based on homomorphic encryption: Design and evaluation Repository for HEAAN Comparison between different FHE framework","title":"References"},{"location":"Glossary/aBits/","text":"aBits is used in the function CipherGD::encSigmoid . There are two places aBits are used: scheme.addConstAndEqual and scheme.multByConst . scheme.addConstAndEqual(encIP2, degree3[1] / degree3[2], wBits - 2 * aBits) ... scheme.multByConst(encGrad[i], encZData[i], gamma * degree3[2], wBits + 3 * aBits) In both places, it were used to align the operands (as logp and mod ).","title":"aBits"},{"location":"Glossary/batch/","text":"If there are many features(columns) in the training data, each sample is divided into multiple batches, and each batch corresponds to one slot. Batch number is calculated as: \\(pow(2, min(log_2N - 1 - sdimBits, fdimBits))\\) This basically says If there are many samples (sdimBits is large enough), batch would be \\(pow(2, log_2N-1-sdimBits)\\) . Otherwise, using the featureCount as batch number","title":"Batch"},{"location":"Glossary/cipherCount/","text":"cipherCount is the number of Ciphertext . calculated as: \\(ceil(featureCount / batch)\\) So generally, it can be seen as how many features are there in one batch . It was originally called cnum .","title":"cipherCount"},{"location":"Glossary/cnum/","text":"Renamed as cipherCount","title":"Cnum"},{"location":"Glossary/factorDim/","text":"Renamed as featureCount","title":"factorDim"},{"location":"Glossary/fdimBits/","text":"The minimum bits required to identify factorDim . For example, if there are 9 features, fdimBits will be 4. Since we need at least 4 bits to represent 9 possible features. If there are only 8 features, then fdimBits will be 3.","title":"fdimBits"},{"location":"Glossary/featureCount/","text":"Refers to the number of features (i.e. the number of columns) in the training file. The original variable name was factorDim , factor dimension.","title":"featureCount"},{"location":"Glossary/kBits/","text":"Minimum bits required to identify each coefficient of the approximating function. Hence, it is \\(ceil(log_2kdeg)\\) .","title":"kBits"},{"location":"Glossary/kdeg/","text":"The degree of the function approximating sigmoid function, the higher the degree is, the more accurate the result will be. It will also consume more noise budget. Possible options are 3 , 5 , 7 static double degree3[3] = {-0.5,0.15012,-0.001593}; static double degree5[4] = {-0.5,0.19131,-0.0045963, 0.0000412332}; static double degree7[5] = {-0.5,0.216884,-0.00819276,0.000165861,-0.00000119581};","title":"Kdeg"},{"location":"Glossary/lBits/","text":"This is only used in the commented out heuristic calculation for logQ long logQ = isInitZero ? (wBits + lBits) + numIter * ((kBits + 1) * wBits + 2 * pBits + aBits) : (sdimBits + wBits + lBits) + numIter * ((kBits + 1) * wBits + 2 * pBits + aBits) However, logL also appears in the function Scheme::addBootKey and logL , logSlots , logN seems to be used interchangebly.","title":"lBits"},{"location":"Glossary/logN/","text":"\\(N\\) is the maximum possible number of slot , default to \\(2^{16}\\) . Similar to logQ , changing this variables after compiling HEAAN results in errors. It needs to be changed before compiling HEAAN in HEAAN/src/Params.h","title":"logN"},{"location":"Glossary/logP/","text":"\\(P\\) is the scaling factor for the HEAAN scheme. \\(logP\\) is \\(log_2P\\) . Also called pBits in IDASH/src/TestGD.cpp . \\(logP\\) is the amount which will be discarded each time we rescale, causing logQ to decrease.","title":"logP"},{"location":"Glossary/logQ/","text":"\\(Q\\) is the noise budget in the HEAAN scheme. One thing to note is that although HEAAN allows \\(logQ\\) to be passed into scheme.encrypt , simply pass it in doesn't actually work. Because the way HEAAN was written, \\(logQ\\) has to be changed before compiling HEAAN (in HEAAN/src/Params.h )","title":"logQ"},{"location":"Glossary/logT/","text":"T his is something related to Tyler approximation. long logT = 4; //< this means that we use Taylor approximation in [-1/T,1/T] with double angle fomula Used in scheme.evalExpAndEqual","title":"logT"},{"location":"Glossary/sampleCount/","text":"Refers to the number of samples (i.e. the number of rows) in the training file. The original variable name was sampleDim , sample dimension.","title":"sampleCount"},{"location":"Glossary/sampleDim/","text":"Renamed as sampleCount","title":"sampleDim"},{"location":"Glossary/sdimBits/","text":"The minimum bits required to identify sampleDim . For example, if there are 9 samples, sdimBits will be 4. Since we need at least 4 bits to represent 9 possible samples. If there are only 8 samples, then sdimBits will be 3.","title":"sdimBits"},{"location":"Glossary/slot/","text":"Slot is similar to batch , except we can identify each slot in all samples. If one sample is divided into two batches, and we have 1000 samples, then there are 2000 slots in total. The maximum number of slots is directly related to N . slot is calculated as: \\(pow(2, sdimBits + batchBits)\\)","title":"Slot"},{"location":"Glossary/wBits/","text":"The bit length of a single number to be encrypted. Default to 30 .","title":"wBits"},{"location":"IDASH/CipherGD/","text":"IDASH/src/CipherGD is the bridge between HEAAN and IDASH. Most operations on the encrypted data happens here, and it can be seen as the encrypted version of IDASH/src/GD . For example, CipherGD.encSigmoid is the counterpart of GD::plainSigmoid plainSigmoid \u00b6 // plainSigmoid for (long i = 0; i < factorDim; ++i) { for (long j = 0; j < sampleDim; ++j) { grad[i] += (degree3[0] + ip[j] * degree3[1] + pow(ip[j], 3) * degree3[2]) * zData[j][i]; } grad[i] *= gamma; } encSigmoid \u00b6 scheme.addConstAndEqual(encIP2, degree3[1] / degree3[2], wBits - 2 * aBits); NTL_EXEC_RANGE(cnum, first, last); for (long i = first; i < last; ++i) { // grad[i] *= gamma * degree3[2] scheme.multByConst(encGrad[i], encZData[i], gamma * degree3[2], wBits + 3 * aBits); scheme.reScaleByAndEqual(encGrad[i], wBits); scheme.modDownToAndEqual(encGrad[i], encIP.logq); // grad[i] *= ip scheme.multAndEqual(encGrad[i], encIP); scheme.reScaleByAndEqual(encGrad[i], wBits); // grad[i] *= ip^2 scheme.multAndEqual(encGrad[i], encIP2); scheme.reScaleByAndEqual(encGrad[i], wBits); Ciphertext tmp; // tmp = grad[i] * gamma * degree3[0] scheme.multByConst(tmp, encZData[i], gamma * degree3[0], wBits); scheme.reScaleByAndEqual(tmp, wBits); scheme.modDownToAndEqual(tmp, encGrad[i].logq); // grad[i] += tmp scheme.addAndEqual(encGrad[i], tmp); } NTL_EXEC_RANGE_END;","title":"CipherGD"},{"location":"IDASH/CipherGD/#plainsigmoid","text":"// plainSigmoid for (long i = 0; i < factorDim; ++i) { for (long j = 0; j < sampleDim; ++j) { grad[i] += (degree3[0] + ip[j] * degree3[1] + pow(ip[j], 3) * degree3[2]) * zData[j][i]; } grad[i] *= gamma; }","title":"plainSigmoid"},{"location":"IDASH/CipherGD/#encsigmoid","text":"scheme.addConstAndEqual(encIP2, degree3[1] / degree3[2], wBits - 2 * aBits); NTL_EXEC_RANGE(cnum, first, last); for (long i = first; i < last; ++i) { // grad[i] *= gamma * degree3[2] scheme.multByConst(encGrad[i], encZData[i], gamma * degree3[2], wBits + 3 * aBits); scheme.reScaleByAndEqual(encGrad[i], wBits); scheme.modDownToAndEqual(encGrad[i], encIP.logq); // grad[i] *= ip scheme.multAndEqual(encGrad[i], encIP); scheme.reScaleByAndEqual(encGrad[i], wBits); // grad[i] *= ip^2 scheme.multAndEqual(encGrad[i], encIP2); scheme.reScaleByAndEqual(encGrad[i], wBits); Ciphertext tmp; // tmp = grad[i] * gamma * degree3[0] scheme.multByConst(tmp, encZData[i], gamma * degree3[0], wBits); scheme.reScaleByAndEqual(tmp, wBits); scheme.modDownToAndEqual(tmp, encGrad[i].logq); // grad[i] += tmp scheme.addAndEqual(encGrad[i], tmp); } NTL_EXEC_RANGE_END;","title":"encSigmoid"},{"location":"IDASH/IDASH2017%20CLI%20arguments/","text":"Argument Description trainfile Training data file path. isYfirst Whether the labels are in the first column in the trainfile. If 0 , the last column will be used as labels. numIter Number of iteration to train the model. kdeg The degree of the function approximating sigmoid function, the higher the degree is, the more accurate the result will be. It will also consume more noise budget. Possible options are 3 , 5 , 7 gammaUp Learning rate parameter gammaDown Learning rate parameter isInitZero Whether to initialize the weight vector to zero. If 0 , the weight will be initialized as the average of each column fold Divide the training data into this many folds for k-fold cross validation isEncrypted Wheter to encrypt the data using the HEAAN (CKKS) scheme. If 0 , the calculation will be done without encryption testfile Filepath to the test data. If provided, instead of k-fold cross validation, this data will be used as validation set","title":"IDASH2017 CLI arguments"},{"location":"IDASH/TestGD/","text":"TestGD contains mostly high level operations focusing on gradient decent itself. When isEncrypted is set to 1 , testEncNLGD or testEncNLGDFOLD is called, otherwise testPlainNLGD or testPlainNLGDFOLD is called. When the testfile is provided, testEncNLGD or testPlainNLGD is called, otherwise testEncNLGDFOLD or testPlainNLGDFOLD is called. testEncNLGDFOLD \u00b6 Initialize fdimBits , sdimBits , wBits , pBits etc. Create Ring , SecretKey , Ciphertext etc. For each fold: Encrypt the data with cipherGD.encZData Create the encrypted weights data with cipherGD.encWVDataZero or cipherGD.encWVDataAverage Calculate the encrypted gradient descent in cipherGD.encNLGDiteration Calculate the plain gradient descent in GD::plainNLGDiteration for comparing the correctness at the end","title":"TestGD"},{"location":"IDASH/TestGD/#testencnlgdfold","text":"Initialize fdimBits , sdimBits , wBits , pBits etc. Create Ring , SecretKey , Ciphertext etc. For each fold: Encrypt the data with cipherGD.encZData Create the encrypted weights data with cipherGD.encWVDataZero or cipherGD.encWVDataAverage Calculate the encrypted gradient descent in cipherGD.encNLGDiteration Calculate the plain gradient descent in GD::plainNLGDiteration for comparing the correctness at the end","title":"testEncNLGDFOLD"},{"location":"Related%20Materials/Background%20Knowledge/","text":"Linear Algebra Cryptography from Khan Academy Abstract algebra Introduction to Homomorphic Encryption (by Pascal Paillier) Intro to Homomorphic Encryption by Microsoft Other introductory material Homomorphic Encryption for Beginners: A Practical Guide An Intro to Fully Homomorphic Encryption for Engineers","title":"Background Knowledge"}]}